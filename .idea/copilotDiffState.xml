<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Bispo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Bispo.java" />
              <option name="updatedContent" value="public class Bispo extends Peca {&#10;    public Bispo(Cor cor, int linha, int coluna) {&#10;        super(cor, linha, coluna);&#10;    }&#10;&#10;    @Override&#10;    public boolean movimentoValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro) {&#10;        int dl = Math.abs(destinoLinha - linha);&#10;        int dc = Math.abs(destinoColuna - coluna);&#10;        return dl == dc;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return cor == Cor.BRANCO ? &quot;♗&quot; : &quot;♝&quot;;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Cavalo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Cavalo.java" />
              <option name="updatedContent" value="public class Cavalo extends Peca {&#10;    public Cavalo(Cor cor, int linha, int coluna) {&#10;        super(cor, linha, coluna);&#10;    }&#10;&#10;    @Override&#10;    public boolean movimentoValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro) {&#10;        int dl = Math.abs(destinoLinha - linha);&#10;        int dc = Math.abs(destinoColuna - coluna);&#10;        return (dl == 2 &amp;&amp; dc == 1) || (dl == 1 &amp;&amp; dc == 2);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return cor == Cor.BRANCO ? &quot;♘&quot; : &quot;♞&quot;;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Cor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Cor.java" />
              <option name="updatedContent" value="public enum Cor {&#10;    BRANCO,&#10;    PRETO&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Peao.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Peao.java" />
              <option name="originalContent" value="public class Peao extends Peca {&#10;    public Peao(Cor cor, int linha, int coluna) {&#10;        super(cor, linha, coluna);&#10;    }&#10;&#10;    @Override&#10;    public boolean movimentoValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro) {&#10;        int direcao = (cor == Cor.BRANCO) ? -1 : 1;&#10;        // Movimento simples para frente&#10;        if (coluna == destinoColuna &amp;&amp; tabuleiro.getPeca(destinoLinha, destinoColuna) == null) {&#10;            if (destinoLinha - linha == direcao) return true;&#10;            // Primeiro movimento pode avançar duas casas&#10;            if ((cor == Cor.BRANCO &amp;&amp; linha == 6 || cor == Cor.PRETO &amp;&amp; linha == 1) &amp;&amp; destinoLinha - linha == 2 * direcao) {&#10;                return tabuleiro.getPeca(linha + direcao, coluna) == null;&#10;            }&#10;        }&#10;        // Captura diagonal&#10;        if (Math.abs(destinoColuna - coluna) == 1 &amp;&amp; destinoLinha - linha == direcao) {&#10;            Peca alvo = tabuleiro.getPeca(destinoLinha, destinoColuna);&#10;            if (alvo != null &amp;&amp; alvo.getCor() != cor) return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return cor == Cor.BRANCO ? &quot;♙&quot; : &quot;♟&quot;;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="public class Peao extends Peca {&#10;    public Peao(Cor cor, int linha, int coluna) {&#10;        super(cor, linha, coluna);&#10;    }&#10;&#10;    // Adiciona suporte ao movimento en passant&#10;    private boolean enPassantValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro) {&#10;        // Verifica se o Tabuleiro permite en passant para esta casa&#10;        return tabuleiro.enPassantDisponivel(destinoLinha, destinoColuna, cor);&#10;    }&#10;&#10;    @Override&#10;    public boolean movimentoValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro) {&#10;        int direcao = (cor == Cor.BRANCO) ? -1 : 1;&#10;        // Movimento simples para frente&#10;        if (coluna == destinoColuna &amp;&amp; tabuleiro.getPeca(destinoLinha, destinoColuna) == null) {&#10;            if (destinoLinha - linha == direcao) return true;&#10;            // Primeiro movimento pode avançar duas casas&#10;            if ((cor == Cor.BRANCO &amp;&amp; linha == 6 || cor == Cor.PRETO &amp;&amp; linha == 1) &amp;&amp; destinoLinha - linha == 2 * direcao) {&#10;                return tabuleiro.getPeca(linha + direcao, coluna) == null;&#10;            }&#10;        }&#10;        // Captura diagonal&#10;        if (Math.abs(destinoColuna - coluna) == 1 &amp;&amp; destinoLinha - linha == direcao) {&#10;            Peca alvo = tabuleiro.getPeca(destinoLinha, destinoColuna);&#10;            if (alvo != null &amp;&amp; alvo.getCor() != cor) return true;&#10;            // En passant&#10;            if (enPassantValido(destinoLinha, destinoColuna, tabuleiro)) return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return cor == Cor.BRANCO ? &quot;♙&quot; : &quot;♟&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Peca.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Peca.java" />
              <option name="updatedContent" value="public abstract class Peca {&#10;    protected Cor cor;&#10;    protected int linha;&#10;    protected int coluna;&#10;&#10;    public Peca(Cor cor, int linha, int coluna) {&#10;        this.cor = cor;&#10;        this.linha = linha;&#10;        this.coluna = coluna;&#10;    }&#10;&#10;    public Cor getCor() {&#10;        return cor;&#10;    }&#10;&#10;    public int getLinha() {&#10;        return linha;&#10;    }&#10;&#10;    public int getColuna() {&#10;        return coluna;&#10;    }&#10;&#10;    public void setPosicao(int linha, int coluna) {&#10;        this.linha = linha;&#10;        this.coluna = coluna;&#10;    }&#10;&#10;    public abstract boolean movimentoValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro);&#10;    public abstract String toString();&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Rainha.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Rainha.java" />
              <option name="updatedContent" value="public class Rainha extends Peca {&#10;    public Rainha(Cor cor, int linha, int coluna) {&#10;        super(cor, linha, coluna);&#10;    }&#10;&#10;    @Override&#10;    public boolean movimentoValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro) {&#10;        int dl = Math.abs(destinoLinha - linha);&#10;        int dc = Math.abs(destinoColuna - coluna);&#10;        return (dl == dc || linha == destinoLinha || coluna == destinoColuna);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return cor == Cor.BRANCO ? &quot;♕&quot; : &quot;♛&quot;;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Rei.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Rei.java" />
              <option name="updatedContent" value="public class Rei extends Peca {&#10;    public Rei(Cor cor, int linha, int coluna) {&#10;        super(cor, linha, coluna);&#10;    }&#10;&#10;    @Override&#10;    public boolean movimentoValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro) {&#10;        int dl = Math.abs(destinoLinha - linha);&#10;        int dc = Math.abs(destinoColuna - coluna);&#10;        return (dl &lt;= 1 &amp;&amp; dc &lt;= 1);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return cor == Cor.BRANCO ? &quot;♔&quot; : &quot;♚&quot;;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Tabuleiro.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Tabuleiro.java" />
              <option name="originalContent" value="import java.util.*;&#10;&#10;public class Tabuleiro {&#10;    private Peca[][] casas;&#10;    public static final int TAMANHO = 8;&#10;    private Cor turno = Cor.BRANCO;&#10;&#10;    private boolean reiBrancoMovido = false;&#10;    private boolean reiPretoMovido = false;&#10;    private boolean torreBrancaEsqMovida = false;&#10;    private boolean torreBrancaDirMovida = false;&#10;    private boolean torrePretaEsqMovida = false;&#10;    private boolean torrePretaDirMovida = false;&#10;    private int enPassantLinha = -1;&#10;    private int enPassantColuna = -1;&#10;    private List&lt;String&gt; historicoJogadas = new ArrayList&lt;&gt;();&#10;&#10;    public Tabuleiro() {&#10;        casas = new Peca[TAMANHO][TAMANHO];&#10;        inicializar();&#10;    }&#10;&#10;    public void inicializar() {&#10;        // Coloca as peças pretas&#10;        casas[0][0] = new Torre(Cor.PRETO, 0, 0);&#10;        casas[0][1] = new Cavalo(Cor.PRETO, 0, 1);&#10;        casas[0][2] = new Bispo(Cor.PRETO, 0, 2);&#10;        casas[0][3] = new Rainha(Cor.PRETO, 0, 3);&#10;        casas[0][4] = new Rei(Cor.PRETO, 0, 4);&#10;        casas[0][5] = new Bispo(Cor.PRETO, 0, 5);&#10;        casas[0][6] = new Cavalo(Cor.PRETO, 0, 6);&#10;        casas[0][7] = new Torre(Cor.PRETO, 0, 7);&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            casas[1][i] = new Peao(Cor.PRETO, 1, i);&#10;        }&#10;        // Coloca as peças brancas&#10;        casas[7][0] = new Torre(Cor.BRANCO, 7, 0);&#10;        casas[7][1] = new Cavalo(Cor.BRANCO, 7, 1);&#10;        casas[7][2] = new Bispo(Cor.BRANCO, 7, 2);&#10;        casas[7][3] = new Rainha(Cor.BRANCO, 7, 3);&#10;        casas[7][4] = new Rei(Cor.BRANCO, 7, 4);&#10;        casas[7][5] = new Bispo(Cor.BRANCO, 7, 5);&#10;        casas[7][6] = new Cavalo(Cor.BRANCO, 7, 6);&#10;        casas[7][7] = new Torre(Cor.BRANCO, 7, 7);&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            casas[6][i] = new Peao(Cor.BRANCO, 6, i);&#10;        }&#10;    }&#10;&#10;    public Peca getPeca(int linha, int coluna) {&#10;        return casas[linha][coluna];&#10;    }&#10;&#10;    public Cor getTurno() {&#10;        return turno;&#10;    }&#10;&#10;    private boolean podeRoque(int origemLinha, int origemColuna, int destinoLinha, int destinoColuna) {&#10;        // Roque branco&#10;        if (getPeca(origemLinha, origemColuna) instanceof Rei &amp;&amp; getPeca(origemLinha, origemColuna).getCor() == Cor.BRANCO &amp;&amp; origemLinha == 7 &amp;&amp; origemColuna == 4) {&#10;            // Roque pequeno&#10;            if (destinoLinha == 7 &amp;&amp; destinoColuna == 6 &amp;&amp; !reiBrancoMovido &amp;&amp; !torreBrancaDirMovida &amp;&amp; getPeca(7,5) == null &amp;&amp; getPeca(7,6) == null) {&#10;                if (!estaEmXeque(Cor.BRANCO) &amp;&amp; !casaAtacada(7,5,Cor.PRETO) &amp;&amp; !casaAtacada(7,6,Cor.PRETO)) {&#10;                    return true;&#10;                }&#10;            }&#10;            // Roque grande&#10;            if (destinoLinha == 7 &amp;&amp; destinoColuna == 2 &amp;&amp; !reiBrancoMovido &amp;&amp; !torreBrancaEsqMovida &amp;&amp; getPeca(7,1) == null &amp;&amp; getPeca(7,2) == null &amp;&amp; getPeca(7,3) == null) {&#10;                if (!estaEmXeque(Cor.BRANCO) &amp;&amp; !casaAtacada(7,3,Cor.PRETO) &amp;&amp; !casaAtacada(7,2,Cor.PRETO)) {&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;        // Roque preto&#10;        if (getPeca(origemLinha, origemColuna) instanceof Rei &amp;&amp; getPeca(origemLinha, origemColuna).getCor() == Cor.PRETO &amp;&amp; origemLinha == 0 &amp;&amp; origemColuna == 4) {&#10;            // Roque pequeno&#10;            if (destinoLinha == 0 &amp;&amp; destinoColuna == 6 &amp;&amp; !reiPretoMovido &amp;&amp; !torrePretaDirMovida &amp;&amp; getPeca(0,5) == null &amp;&amp; getPeca(0,6) == null) {&#10;                if (!estaEmXeque(Cor.PRETO) &amp;&amp; !casaAtacada(0,5,Cor.BRANCO) &amp;&amp; !casaAtacada(0,6,Cor.BRANCO)) {&#10;                    return true;&#10;                }&#10;            }&#10;            // Roque grande&#10;            if (destinoLinha == 0 &amp;&amp; destinoColuna == 2 &amp;&amp; !reiPretoMovido &amp;&amp; !torrePretaEsqMovida &amp;&amp; getPeca(0,1) == null &amp;&amp; getPeca(0,2) == null &amp;&amp; getPeca(0,3) == null) {&#10;                if (!estaEmXeque(Cor.PRETO) &amp;&amp; !casaAtacada(0,3,Cor.BRANCO) &amp;&amp; !casaAtacada(0,2,Cor.BRANCO)) {&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean casaAtacada(int linha, int coluna, Cor atacante) {&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() == atacante) {&#10;                    if (p.movimentoValido(linha, coluna, this)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public boolean movimentoValido(int origemLinha, int origemColuna, int destinoLinha, int destinoColuna) {&#10;        Peca peca = getPeca(origemLinha, origemColuna);&#10;        if (peca == null || peca.getCor() != turno) return false;&#10;        if (peca instanceof Rei &amp;&amp; podeRoque(origemLinha, origemColuna, destinoLinha, destinoColuna)) return true;&#10;        if (!peca.movimentoValido(destinoLinha, destinoColuna, this)) return false;&#10;        // Não pode capturar peça da mesma cor&#10;        Peca destino = getPeca(destinoLinha, destinoColuna);&#10;        if (destino != null &amp;&amp; destino.getCor() == turno) return false;&#10;        // Simula movimento para verificar xeque&#10;        Peca[][] backup = copiarCasas();&#10;        moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;        boolean emXeque = estaEmXeque(turno);&#10;        casas = backup;&#10;        return !emXeque;&#10;    }&#10;&#10;    private Peca[][] copiarCasas() {&#10;        Peca[][] copia = new Peca[TAMANHO][TAMANHO];&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                copia[i][j] = casas[i][j];&#10;            }&#10;        }&#10;        return copia;&#10;    }&#10;&#10;    public boolean estaEmXeque(Cor cor) {&#10;        int reiLinha = -1, reiColuna = -1;&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p instanceof Rei &amp;&amp; p.getCor() == cor) {&#10;                    reiLinha = i;&#10;                    reiColuna = j;&#10;                }&#10;            }&#10;        }&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() != cor) {&#10;                    if (p.movimentoValido(reiLinha, reiColuna, this)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public boolean estaEmXequeMate(Cor cor) {&#10;        if (!estaEmXeque(cor)) return false;&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() == cor) {&#10;                    for (int x = 0; x &lt; TAMANHO; x++) {&#10;                        for (int y = 0; y &lt; TAMANHO; y++) {&#10;                            if (movimentoValido(i, j, x, y)) {&#10;                                return false;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    // Verifica empate por afogamento (stalemate)&#10;    public boolean estaAfogamento(Cor cor) {&#10;        if (estaEmXeque(cor)) return false;&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() == cor) {&#10;                    for (int x = 0; x &lt; TAMANHO; x++) {&#10;                        for (int y = 0; y &lt; TAMANHO; y++) {&#10;                            if (movimentoValido(i, j, x, y)) {&#10;                                return false;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public boolean enPassantDisponivel(int destinoLinha, int destinoColuna, Cor cor) {&#10;        if (enPassantLinha == destinoLinha &amp;&amp; enPassantColuna == destinoColuna) {&#10;            // Só pode capturar en passant na jogada seguinte&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public Map&lt;String, Integer&gt; contarPecas(Cor cor) {&#10;        Map&lt;String, Integer&gt; contagem = new HashMap&lt;&gt;();&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() == cor) {&#10;                    String tipo = p.getClass().getSimpleName();&#10;                    contagem.put(tipo, contagem.getOrDefault(tipo, 0) + 1);&#10;                }&#10;            }&#10;        }&#10;        return contagem;&#10;    }&#10;&#10;    public List&lt;String&gt; getHistoricoJogadas() {&#10;        return historicoJogadas;&#10;    }&#10;&#10;    public String exportarPartida() {&#10;        StringBuilder sb = new StringBuilder();&#10;        int num = 1;&#10;        for (String jogada : historicoJogadas) {&#10;            sb.append(num++).append(&quot;. &quot;).append(jogada).append(&quot;\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private String posicaoToStr(int linha, int coluna) {&#10;        return &quot;&quot; + (char)('a' + coluna) + (8 - linha);&#10;    }&#10;&#10;    @Override&#10;    public void moverPecaComRegras(int origemLinha, int origemColuna, int destinoLinha, int destinoColuna) {&#10;        if (!movimentoValido(origemLinha, origemColuna, destinoLinha, destinoColuna)) return;&#10;        Peca p = getPeca(origemLinha, origemColuna);&#10;        // Roque&#10;        if (p instanceof Rei &amp;&amp; podeRoque(origemLinha, origemColuna, destinoLinha, destinoColuna)) {&#10;            if (p.getCor() == Cor.BRANCO) {&#10;                reiBrancoMovido = true;&#10;                if (destinoColuna == 6) { // Roque pequeno&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    moverPeca(7,7,7,5);&#10;                    torreBrancaDirMovida = true;&#10;                } else { // Roque grande&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    moverPeca(7,0,7,3);&#10;                    torreBrancaEsqMovida = true;&#10;                }&#10;            } else {&#10;                reiPretoMovido = true;&#10;                if (destinoColuna == 6) { // Roque pequeno&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    moverPeca(0,7,0,5);&#10;                    torrePretaDirMovida = true;&#10;                } else { // Roque grande&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    moverPeca(0,0,0,3);&#10;                    torrePretaEsqMovida = true;&#10;                }&#10;            }&#10;        } else {&#10;            // En passant&#10;            if (p instanceof Peao &amp;&amp; Math.abs(destinoColuna - origemColuna) == 1 &amp;&amp; getPeca(destinoLinha, destinoColuna) == null) {&#10;                if (enPassantDisponivel(destinoLinha, destinoColuna, p.getCor())) {&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    // Remove o peão capturado&#10;                    if (p.getCor() == Cor.BRANCO) casas[destinoLinha + 1][destinoColuna] = null;&#10;                    else casas[destinoLinha - 1][destinoColuna] = null;&#10;                } else {&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                }&#10;            } else {&#10;                moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;            }&#10;            // Atualiza flags de movimento&#10;            if (p instanceof Rei) {&#10;                if (p.getCor() == Cor.BRANCO) reiBrancoMovido = true;&#10;                else reiPretoMovido = true;&#10;            }&#10;            if (p instanceof Torre) {&#10;                if (p.getCor() == Cor.BRANCO) {&#10;                    if (origemLinha == 7 &amp;&amp; origemColuna == 0) torreBrancaEsqMovida = true;&#10;                    if (origemLinha == 7 &amp;&amp; origemColuna == 7) torreBrancaDirMovida = true;&#10;                } else {&#10;                    if (origemLinha == 0 &amp;&amp; origemColuna == 0) torrePretaEsqMovida = true;&#10;                    if (origemLinha == 0 &amp;&amp; origemColuna == 7) torrePretaDirMovida = true;&#10;                }&#10;            }&#10;        }&#10;        // Controle de en passant&#10;        enPassantLinha = -1;&#10;        enPassantColuna = -1;&#10;        if (p instanceof Peao &amp;&amp; Math.abs(destinoLinha - origemLinha) == 2) {&#10;            enPassantLinha = (origemLinha + destinoLinha) / 2;&#10;            enPassantColuna = origemColuna;&#10;        }&#10;        // Promoção de peão&#10;        if (p instanceof Peao) {&#10;            if ((p.getCor() == Cor.BRANCO &amp;&amp; destinoLinha == 0) || (p.getCor() == Cor.PRETO &amp;&amp; destinoLinha == 7)) {&#10;                casas[destinoLinha][destinoColuna] = new Rainha(p.getCor(), destinoLinha, destinoColuna);&#10;            }&#10;        }&#10;        // Adiciona ao histórico&#10;        Peca pc = getPeca(destinoLinha, destinoColuna);&#10;        String tipo = pc != null ? pc.getClass().getSimpleName() : &quot;&quot;;&#10;        historicoJogadas.add(tipo + &quot;: &quot; + posicaoToStr(origemLinha, origemColuna) + &quot; -&gt; &quot; + posicaoToStr(destinoLinha, destinoColuna));&#10;        turno = (turno == Cor.BRANCO) ? Cor.PRETO : Cor.BRANCO;&#10;    }&#10;&#10;    public void imprimir() {&#10;        for (int linha = 0; linha &lt; TAMANHO; linha++) {&#10;            for (int coluna = 0; coluna &lt; TAMANHO; coluna++) {&#10;                Peca peca = casas[linha][coluna];&#10;                if (peca == null) {&#10;                    System.out.print(&quot;- &quot;);&#10;                } else {&#10;                    System.out.print(peca + &quot; &quot;);&#10;                }&#10;            }&#10;            System.out.println();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.util.*;&#10;&#10;public class Tabuleiro {&#10;    private Peca[][] casas;&#10;    public static final int TAMANHO = 8;&#10;    private Cor turno = Cor.BRANCO;&#10;&#10;    private boolean reiBrancoMovido = false;&#10;    private boolean reiPretoMovido = false;&#10;    private boolean torreBrancaEsqMovida = false;&#10;    private boolean torreBrancaDirMovida = false;&#10;    private boolean torrePretaEsqMovida = false;&#10;    private boolean torrePretaDirMovida = false;&#10;    private int enPassantLinha = -1;&#10;    private int enPassantColuna = -1;&#10;    private List&lt;String&gt; historicoJogadas = new ArrayList&lt;&gt;();&#10;&#10;    public Tabuleiro() {&#10;        casas = new Peca[TAMANHO][TAMANHO];&#10;        inicializar();&#10;    }&#10;&#10;    public void inicializar() {&#10;        // Coloca as peças pretas&#10;        casas[0][0] = new Torre(Cor.PRETO, 0, 0);&#10;        casas[0][1] = new Cavalo(Cor.PRETO, 0, 1);&#10;        casas[0][2] = new Bispo(Cor.PRETO, 0, 2);&#10;        casas[0][3] = new Rainha(Cor.PRETO, 0, 3);&#10;        casas[0][4] = new Rei(Cor.PRETO, 0, 4);&#10;        casas[0][5] = new Bispo(Cor.PRETO, 0, 5);&#10;        casas[0][6] = new Cavalo(Cor.PRETO, 0, 6);&#10;        casas[0][7] = new Torre(Cor.PRETO, 0, 7);&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            casas[1][i] = new Peao(Cor.PRETO, 1, i);&#10;        }&#10;        // Coloca as peças brancas&#10;        casas[7][0] = new Torre(Cor.BRANCO, 7, 0);&#10;        casas[7][1] = new Cavalo(Cor.BRANCO, 7, 1);&#10;        casas[7][2] = new Bispo(Cor.BRANCO, 7, 2);&#10;        casas[7][3] = new Rainha(Cor.BRANCO, 7, 3);&#10;        casas[7][4] = new Rei(Cor.BRANCO, 7, 4);&#10;        casas[7][5] = new Bispo(Cor.BRANCO, 7, 5);&#10;        casas[7][6] = new Cavalo(Cor.BRANCO, 7, 6);&#10;        casas[7][7] = new Torre(Cor.BRANCO, 7, 7);&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            casas[6][i] = new Peao(Cor.BRANCO, 6, i);&#10;        }&#10;    }&#10;&#10;    public Peca getPeca(int linha, int coluna) {&#10;        return casas[linha][coluna];&#10;    }&#10;&#10;    public Cor getTurno() {&#10;        return turno;&#10;    }&#10;&#10;    private boolean podeRoque(int origemLinha, int origemColuna, int destinoLinha, int destinoColuna) {&#10;        // Roque branco&#10;        if (getPeca(origemLinha, origemColuna) instanceof Rei &amp;&amp; getPeca(origemLinha, origemColuna).getCor() == Cor.BRANCO &amp;&amp; origemLinha == 7 &amp;&amp; origemColuna == 4) {&#10;            // Roque pequeno&#10;            if (destinoLinha == 7 &amp;&amp; destinoColuna == 6 &amp;&amp; !reiBrancoMovido &amp;&amp; !torreBrancaDirMovida &amp;&amp; getPeca(7,5) == null &amp;&amp; getPeca(7,6) == null) {&#10;                if (!estaEmXeque(Cor.BRANCO) &amp;&amp; !casaAtacada(7,5,Cor.PRETO) &amp;&amp; !casaAtacada(7,6,Cor.PRETO)) {&#10;                    return true;&#10;                }&#10;            }&#10;            // Roque grande&#10;            if (destinoLinha == 7 &amp;&amp; destinoColuna == 2 &amp;&amp; !reiBrancoMovido &amp;&amp; !torreBrancaEsqMovida &amp;&amp; getPeca(7,1) == null &amp;&amp; getPeca(7,2) == null &amp;&amp; getPeca(7,3) == null) {&#10;                if (!estaEmXeque(Cor.BRANCO) &amp;&amp; !casaAtacada(7,3,Cor.PRETO) &amp;&amp; !casaAtacada(7,2,Cor.PRETO)) {&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;        // Roque preto&#10;        if (getPeca(origemLinha, origemColuna) instanceof Rei &amp;&amp; getPeca(origemLinha, origemColuna).getCor() == Cor.PRETO &amp;&amp; origemLinha == 0 &amp;&amp; origemColuna == 4) {&#10;            // Roque pequeno&#10;            if (destinoLinha == 0 &amp;&amp; destinoColuna == 6 &amp;&amp; !reiPretoMovido &amp;&amp; !torrePretaDirMovida &amp;&amp; getPeca(0,5) == null &amp;&amp; getPeca(0,6) == null) {&#10;                if (!estaEmXeque(Cor.PRETO) &amp;&amp; !casaAtacada(0,5,Cor.BRANCO) &amp;&amp; !casaAtacada(0,6,Cor.BRANCO)) {&#10;                    return true;&#10;                }&#10;            }&#10;            // Roque grande&#10;            if (destinoLinha == 0 &amp;&amp; destinoColuna == 2 &amp;&amp; !reiPretoMovido &amp;&amp; !torrePretaEsqMovida &amp;&amp; getPeca(0,1) == null &amp;&amp; getPeca(0,2) == null &amp;&amp; getPeca(0,3) == null) {&#10;                if (!estaEmXeque(Cor.PRETO) &amp;&amp; !casaAtacada(0,3,Cor.BRANCO) &amp;&amp; !casaAtacada(0,2,Cor.BRANCO)) {&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean casaAtacada(int linha, int coluna, Cor atacante) {&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() == atacante) {&#10;                    if (p.movimentoValido(linha, coluna, this)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public boolean movimentoValido(int origemLinha, int origemColuna, int destinoLinha, int destinoColuna) {&#10;        Peca peca = getPeca(origemLinha, origemColuna);&#10;        if (peca == null || peca.getCor() != turno) return false;&#10;        if (peca instanceof Rei &amp;&amp; podeRoque(origemLinha, origemColuna, destinoLinha, destinoColuna)) return true;&#10;        if (!peca.movimentoValido(destinoLinha, destinoColuna, this)) return false;&#10;        // Não pode capturar peça da mesma cor&#10;        Peca destino = getPeca(destinoLinha, destinoColuna);&#10;        if (destino != null &amp;&amp; destino.getCor() == turno) return false;&#10;        // Simula movimento para verificar xeque&#10;        Peca[][] backup = copiarCasas();&#10;        moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;        boolean emXeque = estaEmXeque(turno);&#10;        casas = backup;&#10;        return !emXeque;&#10;    }&#10;&#10;    private Peca[][] copiarCasas() {&#10;        Peca[][] copia = new Peca[TAMANHO][TAMANHO];&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                copia[i][j] = casas[i][j];&#10;            }&#10;        }&#10;        return copia;&#10;    }&#10;&#10;    public boolean estaEmXeque(Cor cor) {&#10;        int reiLinha = -1, reiColuna = -1;&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p instanceof Rei &amp;&amp; p.getCor() == cor) {&#10;                    reiLinha = i;&#10;                    reiColuna = j;&#10;                }&#10;            }&#10;        }&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() != cor) {&#10;                    if (p.movimentoValido(reiLinha, reiColuna, this)) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public boolean estaEmXequeMate(Cor cor) {&#10;        if (!estaEmXeque(cor)) return false;&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() == cor) {&#10;                    for (int x = 0; x &lt; TAMANHO; x++) {&#10;                        for (int y = 0; y &lt; TAMANHO; y++) {&#10;                            if (movimentoValido(i, j, x, y)) {&#10;                                return false;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    // Verifica empate por afogamento (stalemate)&#10;    public boolean estaAfogamento(Cor cor) {&#10;        if (estaEmXeque(cor)) return false;&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() == cor) {&#10;                    for (int x = 0; x &lt; TAMANHO; x++) {&#10;                        for (int y = 0; y &lt; TAMANHO; y++) {&#10;                            if (movimentoValido(i, j, x, y)) {&#10;                                return false;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public boolean enPassantDisponivel(int destinoLinha, int destinoColuna, Cor cor) {&#10;        if (enPassantLinha == destinoLinha &amp;&amp; enPassantColuna == destinoColuna) {&#10;            // Só pode capturar en passant na jogada seguinte&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public Map&lt;String, Integer&gt; contarPecas(Cor cor) {&#10;        Map&lt;String, Integer&gt; contagem = new HashMap&lt;&gt;();&#10;        for (int i = 0; i &lt; TAMANHO; i++) {&#10;            for (int j = 0; j &lt; TAMANHO; j++) {&#10;                Peca p = casas[i][j];&#10;                if (p != null &amp;&amp; p.getCor() == cor) {&#10;                    String tipo = p.getClass().getSimpleName();&#10;                    contagem.put(tipo, contagem.getOrDefault(tipo, 0) + 1);&#10;                }&#10;            }&#10;        }&#10;        return contagem;&#10;    }&#10;&#10;    public List&lt;String&gt; getHistoricoJogadas() {&#10;        return historicoJogadas;&#10;    }&#10;&#10;    public String exportarPartida() {&#10;        StringBuilder sb = new StringBuilder();&#10;        int num = 1;&#10;        for (String jogada : historicoJogadas) {&#10;            sb.append(num++).append(&quot;. &quot;).append(jogada).append(&quot;\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;&#10;    private String posicaoToStr(int linha, int coluna) {&#10;        return &quot;&quot; + (char)('a' + coluna) + (8 - linha);&#10;    }&#10;&#10;    // Adiciona método moverPeca usado internamente&#10;    public void moverPeca(int origemLinha, int origemColuna, int destinoLinha, int destinoColuna) {&#10;        Peca peca = casas[origemLinha][origemColuna];&#10;        casas[destinoLinha][destinoColuna] = peca;&#10;        casas[origemLinha][origemColuna] = null;&#10;        if (peca != null) {&#10;            peca.setPosicao(destinoLinha, destinoColuna);&#10;        }&#10;    }&#10;&#10;    // Adiciona controle de peças capturadas&#10;    private List&lt;String&gt; pecasCapturadas = new ArrayList&lt;&gt;();&#10;    public List&lt;String&gt; getPecasCapturadas() {&#10;        return pecasCapturadas;&#10;    }&#10;    public List&lt;String&gt; getPecasCapturadasPorCor(Cor cor) {&#10;        List&lt;String&gt; lista = new ArrayList&lt;&gt;();&#10;        for (String p : pecasCapturadas) {&#10;            if (p.startsWith(cor == Cor.BRANCO ? &quot;B:&quot; : &quot;P:&quot;)) lista.add(p.substring(2));&#10;        }&#10;        return lista;&#10;    }&#10;&#10;    // Adiciona método para registrar capturas&#10;    private void registrarCaptura(Peca capturada) {&#10;        if (capturada != null) {&#10;            String corStr = capturada.getCor() == Cor.BRANCO ? &quot;B:&quot; : &quot;P:&quot;;&#10;            pecasCapturadas.add(corStr + capturada.getClass().getSimpleName());&#10;        }&#10;    }&#10;&#10;    public void moverPecaComRegras(int origemLinha, int origemColuna, int destinoLinha, int destinoColuna) {&#10;        if (!movimentoValido(origemLinha, origemColuna, destinoLinha, destinoColuna)) return;&#10;        Peca p = getPeca(origemLinha, origemColuna);&#10;        Peca capturada = getPeca(destinoLinha, destinoColuna);&#10;        // Roque&#10;        if (p instanceof Rei &amp;&amp; podeRoque(origemLinha, origemColuna, destinoLinha, destinoColuna)) {&#10;            if (p.getCor() == Cor.BRANCO) {&#10;                reiBrancoMovido = true;&#10;                if (destinoColuna == 6) { // Roque pequeno&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    moverPeca(7,7,7,5);&#10;                    torreBrancaDirMovida = true;&#10;                } else { // Roque grande&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    moverPeca(7,0,7,3);&#10;                    torreBrancaEsqMovida = true;&#10;                }&#10;            } else {&#10;                reiPretoMovido = true;&#10;                if (destinoColuna == 6) { // Roque pequeno&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    moverPeca(0,7,0,5);&#10;                    torrePretaDirMovida = true;&#10;                } else { // Roque grande&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    moverPeca(0,0,0,3);&#10;                    torrePretaEsqMovida = true;&#10;                }&#10;            }&#10;        } else {&#10;            // En passant&#10;            if (p instanceof Peao &amp;&amp; Math.abs(destinoColuna - origemColuna) == 1 &amp;&amp; getPeca(destinoLinha, destinoColuna) == null) {&#10;                if (enPassantDisponivel(destinoLinha, destinoColuna, p.getCor())) {&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                    // Remove o peão capturado&#10;                    if (p.getCor() == Cor.BRANCO) {&#10;                        registrarCaptura(getPeca(destinoLinha + 1, destinoColuna));&#10;                        casas[destinoLinha + 1][destinoColuna] = null;&#10;                    } else {&#10;                        registrarCaptura(getPeca(destinoLinha - 1, destinoColuna));&#10;                        casas[destinoLinha - 1][destinoColuna] = null;&#10;                    }&#10;                } else {&#10;                    registrarCaptura(capturada);&#10;                    moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;                }&#10;            } else {&#10;                registrarCaptura(capturada);&#10;                moverPeca(origemLinha, origemColuna, destinoLinha, destinoColuna);&#10;            }&#10;            // Atualiza flags de movimento&#10;            if (p instanceof Rei) {&#10;                if (p.getCor() == Cor.BRANCO) reiBrancoMovido = true;&#10;                else reiPretoMovido = true;&#10;            }&#10;            if (p instanceof Torre) {&#10;                if (p.getCor() == Cor.BRANCO) {&#10;                    if (origemLinha == 7 &amp;&amp; origemColuna == 0) torreBrancaEsqMovida = true;&#10;                    if (origemLinha == 7 &amp;&amp; origemColuna == 7) torreBrancaDirMovida = true;&#10;                } else {&#10;                    if (origemLinha == 0 &amp;&amp; origemColuna == 0) torrePretaEsqMovida = true;&#10;                    if (origemLinha == 0 &amp;&amp; origemColuna == 7) torrePretaDirMovida = true;&#10;                }&#10;            }&#10;        }&#10;        // Controle de en passant&#10;        enPassantLinha = -1;&#10;        enPassantColuna = -1;&#10;        if (p instanceof Peao &amp;&amp; Math.abs(destinoLinha - origemLinha) == 2) {&#10;            enPassantLinha = (origemLinha + destinoLinha) / 2;&#10;            enPassantColuna = origemColuna;&#10;        }&#10;        // Promoção de peão&#10;        if (p instanceof Peao) {&#10;            if ((p.getCor() == Cor.BRANCO &amp;&amp; destinoLinha == 0) || (p.getCor() == Cor.PRETO &amp;&amp; destinoLinha == 7)) {&#10;                casas[destinoLinha][destinoColuna] = new Rainha(p.getCor(), destinoLinha, destinoColuna);&#10;            }&#10;        }&#10;        // Adiciona ao histórico&#10;        Peca pc = getPeca(destinoLinha, destinoColuna);&#10;        String tipo = pc != null ? pc.getClass().getSimpleName() : &quot;&quot;;&#10;        historicoJogadas.add(tipo + &quot;: &quot; + posicaoToStr(origemLinha, origemColuna) + &quot; -&gt; &quot; + posicaoToStr(destinoLinha, destinoColuna));&#10;        turno = (turno == Cor.BRANCO) ? Cor.PRETO : Cor.BRANCO;&#10;    }&#10;&#10;    public void imprimir() {&#10;        for (int linha = 0; linha &lt; TAMANHO; linha++) {&#10;            for (int coluna = 0; coluna &lt; TAMANHO; coluna++) {&#10;                Peca peca = casas[linha][coluna];&#10;                if (peca == null) {&#10;                    System.out.print(&quot;- &quot;);&#10;                } else {&#10;                    System.out.print(peca + &quot; &quot;);&#10;                }&#10;            }&#10;            System.out.println();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Torre.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Torre.java" />
              <option name="updatedContent" value="public class Torre extends Peca {&#10;    public Torre(Cor cor, int linha, int coluna) {&#10;        super(cor, linha, coluna);&#10;    }&#10;&#10;    @Override&#10;    public boolean movimentoValido(int destinoLinha, int destinoColuna, Tabuleiro tabuleiro) {&#10;        return (linha == destinoLinha || coluna == destinoColuna);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return cor == Cor.BRANCO ? &quot;♖&quot; : &quot;♜&quot;;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/XadrezGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/XadrezGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;&#10;public class XadrezGUI extends JFrame {&#10;    private Tabuleiro tabuleiro;&#10;    private JButton[][] botoes;&#10;    private int origemLinha = -1, origemColuna = -1;&#10;    private JLabel statusLabel;&#10;    private JLabel contagemLabel;&#10;    private JLabel capturadasLabel;&#10;    private JLabel relogioLabel;&#10;    private JTextArea historicoArea;&#10;    private Timer timer;&#10;    private int segundosBranco = 0, segundosPreto = 0;&#10;    private int tempoPersonalizado = 0; // segundos por jogador, 0 = sem limite&#10;&#10;    public XadrezGUI() {&#10;        tabuleiro = new Tabuleiro();&#10;        botoes = new JButton[Tabuleiro.TAMANHO][Tabuleiro.TAMANHO];&#10;        setTitle(&quot;Xadrez&quot;);&#10;        setSize(800, 700);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;        JPanel painelTabuleiro = new JPanel(new GridLayout(Tabuleiro.TAMANHO, Tabuleiro.TAMANHO));&#10;        inicializarBotoes(painelTabuleiro);&#10;        add(painelTabuleiro, BorderLayout.CENTER);&#10;        statusLabel = new JLabel(&quot;Turno: &quot; + tabuleiro.getTurno());&#10;        statusLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 18));&#10;        add(statusLabel, BorderLayout.SOUTH);&#10;        JPanel painelInfo = new JPanel(new BorderLayout());&#10;        contagemLabel = new JLabel();&#10;        contagemLabel.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 16));&#10;        painelInfo.add(contagemLabel, BorderLayout.NORTH);&#10;        historicoArea = new JTextArea(10, 20);&#10;        historicoArea.setEditable(false);&#10;        painelInfo.add(new JScrollPane(historicoArea), BorderLayout.CENTER);&#10;        JButton exportarBtn = new JButton(&quot;Exportar Histórico&quot;);&#10;        exportarBtn.addActionListener(e -&gt; mostrarExportacao());&#10;        painelInfo.add(exportarBtn, BorderLayout.SOUTH);&#10;        capturadasLabel = new JLabel();&#10;        capturadasLabel.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 16));&#10;        painelInfo.add(capturadasLabel, BorderLayout.WEST);&#10;        relogioLabel = new JLabel();&#10;        relogioLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        painelInfo.add(relogioLabel, BorderLayout.EAST);&#10;        JButton tempoBtn = new JButton(&quot;Definir Tempo&quot;);&#10;        tempoBtn.addActionListener(e -&gt; mostrarDialogoTempo());&#10;        painelInfo.add(tempoBtn, BorderLayout.NORTH);&#10;        add(painelInfo, BorderLayout.EAST);&#10;        atualizarTabuleiro();&#10;        atualizarContagemEHistorico();&#10;        iniciarRelogio();&#10;        setVisible(true);&#10;    }&#10;&#10;    private void iniciarRelogio() {&#10;        timer = new Timer(1000, e -&gt; {&#10;            if (tabuleiro.getTurno() == Cor.BRANCO) segundosBranco++;&#10;            else segundosPreto++;&#10;            atualizarRelogio();&#10;            if (tempoPersonalizado &gt; 0) {&#10;                if (segundosBranco &gt;= tempoPersonalizado) {&#10;                    timer.stop();&#10;                    JOptionPane.showMessageDialog(this, &quot;Tempo esgotado para as brancas! Fim de jogo.&quot;, &quot;Tempo&quot;, JOptionPane.INFORMATION_MESSAGE);&#10;                }&#10;                if (segundosPreto &gt;= tempoPersonalizado) {&#10;                    timer.stop();&#10;                    JOptionPane.showMessageDialog(this, &quot;Tempo esgotado para as pretas! Fim de jogo.&quot;, &quot;Tempo&quot;, JOptionPane.INFORMATION_MESSAGE);&#10;                }&#10;            }&#10;        });&#10;        timer.start();&#10;    }&#10;&#10;    private void atualizarRelogio() {&#10;        relogioLabel.setText(&quot;Branco: &quot; + formatarTempo(segundosBranco) + &quot; | Preto: &quot; + formatarTempo(segundosPreto));&#10;    }&#10;&#10;    private String formatarTempo(int s) {&#10;        int min = s / 60;&#10;        int seg = s % 60;&#10;        return String.format(&quot;%02d:%02d&quot;, min, seg);&#10;    }&#10;&#10;    private void salvarHistoricoEmArquivo() {&#10;        JFileChooser chooser = new JFileChooser();&#10;        int op = chooser.showSaveDialog(this);&#10;        if (op == JFileChooser.APPROVE_OPTION) {&#10;            try {&#10;                java.io.File file = chooser.getSelectedFile();&#10;                java.nio.file.Files.write(file.toPath(), tabuleiro.exportarPartida().getBytes());&#10;                JOptionPane.showMessageDialog(this, &quot;Histórico salvo em arquivo!&quot;, &quot;Sucesso&quot;, JOptionPane.INFORMATION_MESSAGE);&#10;            } catch (Exception ex) {&#10;                JOptionPane.showMessageDialog(this, &quot;Erro ao salvar arquivo!&quot;, &quot;Erro&quot;, JOptionPane.ERROR_MESSAGE);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void mostrarExportacao() {&#10;        String texto = tabuleiro.exportarPartida();&#10;        JOptionPane.showMessageDialog(this, texto, &quot;Histórico da Partida&quot;, JOptionPane.INFORMATION_MESSAGE);&#10;        int opt = JOptionPane.showConfirmDialog(this, &quot;Deseja salvar o histórico em arquivo?&quot;, &quot;Salvar&quot;, JOptionPane.YES_NO_OPTION);&#10;        if (opt == JOptionPane.YES_OPTION) {&#10;            salvarHistoricoEmArquivo();&#10;        }&#10;    }&#10;&#10;    private void mostrarDialogoTempo() {&#10;        String min = JOptionPane.showInputDialog(this, &quot;Tempo por jogador (minutos, 0 = sem limite):&quot;, &quot;10&quot;);&#10;        try {&#10;            int minutos = Integer.parseInt(min);&#10;            setTempoPersonalizado(minutos);&#10;        } catch (Exception ex) {&#10;            JOptionPane.showMessageDialog(this, &quot;Valor inválido!&quot;, &quot;Erro&quot;, JOptionPane.ERROR_MESSAGE);&#10;        }&#10;    }&#10;&#10;    // Adiciona método para definir tempo personalizado&#10;    public void setTempoPersonalizado(int minutos) {&#10;        tempoPersonalizado = minutos * 60;&#10;        segundosBranco = 0;&#10;        segundosPreto = 0;&#10;        atualizarRelogio();&#10;    }&#10;&#10;    private void atualizarCapturadas() {&#10;        java.util.List&lt;String&gt; capturadasBrancas = tabuleiro.getPecasCapturadasPorCor(Cor.BRANCO);&#10;        java.util.List&lt;String&gt; capturadasPretas = tabuleiro.getPecasCapturadasPorCor(Cor.PRETO);&#10;        StringBuilder sb = new StringBuilder(&quot;Capturadas - Brancas: &quot;);&#10;        for (String p : capturadasBrancas) sb.append(p).append(&quot; &quot;);&#10;        sb.append(&quot;| Pretas: &quot;);&#10;        for (String p : capturadasPretas) sb.append(p).append(&quot; &quot;);&#10;        capturadasLabel.setText(sb.toString());&#10;    }&#10;&#10;    private void atualizarContagemEHistorico() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;Brancas: &quot;).append(tabuleiro.contarPecas(Cor.BRANCO)).append(&quot;\n&quot;);&#10;        sb.append(&quot;Pretas: &quot;).append(tabuleiro.contarPecas(Cor.PRETO)).append(&quot;\n&quot;);&#10;        contagemLabel.setText(&quot;&lt;html&gt;&quot; + sb.toString().replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;) + &quot;&lt;/html&gt;&quot;);&#10;        StringBuilder hist = new StringBuilder();&#10;        for (String jogada : tabuleiro.getHistoricoJogadas()) {&#10;            hist.append(jogada).append(&quot;\n&quot;);&#10;        }&#10;        historicoArea.setText(hist.toString());&#10;        atualizarCapturadas();&#10;    }&#10;&#10;    private void inicializarBotoes(JPanel painelTabuleiro) {&#10;        for (int linha = 0; linha &lt; Tabuleiro.TAMANHO; linha++) {&#10;            for (int coluna = 0; coluna &lt; Tabuleiro.TAMANHO; coluna++) {&#10;                JButton botao = new JButton();&#10;                botao.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 24));&#10;                botao.setBackground((linha + coluna) % 2 == 0 ? Color.WHITE : Color.GRAY);&#10;                final int l = linha, c = coluna;&#10;                botao.addActionListener(e -&gt; cliqueCasa(l, c));&#10;                botoes[linha][coluna] = botao;&#10;                painelTabuleiro.add(botao);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void cliqueCasa(int linha, int coluna) {&#10;        if (origemLinha == -1 &amp;&amp; tabuleiro.getPeca(linha, coluna) != null &amp;&amp; tabuleiro.getPeca(linha, coluna).getCor() == tabuleiro.getTurno()) {&#10;            origemLinha = linha;&#10;            origemColuna = coluna;&#10;            botoes[linha][coluna].setBackground(Color.YELLOW);&#10;        } else if (origemLinha != -1) {&#10;            if (tabuleiro.movimentoValido(origemLinha, origemColuna, linha, coluna)) {&#10;                tabuleiro.moverPecaComRegras(origemLinha, origemColuna, linha, coluna);&#10;                if (tabuleiro.estaEmXeque(tabuleiro.getTurno())) {&#10;                    statusLabel.setText(&quot;Xeque! Turno: &quot; + tabuleiro.getTurno());&#10;                } else if (tabuleiro.estaEmXequeMate(tabuleiro.getTurno())) {&#10;                    statusLabel.setText(&quot;Xeque-mate! Fim de jogo.&quot;);&#10;                } else if (tabuleiro.estaAfogamento(tabuleiro.getTurno())) {&#10;                    statusLabel.setText(&quot;Empate por afogamento! Fim de jogo.&quot;);&#10;                } else {&#10;                    statusLabel.setText(&quot;Turno: &quot; + tabuleiro.getTurno());&#10;                }&#10;            } else {&#10;                statusLabel.setText(&quot;Movimento inválido! Turno: &quot; + tabuleiro.getTurno());&#10;            }&#10;            botoes[origemLinha][origemColuna].setBackground((origemLinha + origemColuna) % 2 == 0 ? Color.WHITE : Color.GRAY);&#10;            origemLinha = -1;&#10;            origemColuna = -1;&#10;            atualizarTabuleiro();&#10;        }&#10;        atualizarContagemEHistorico();&#10;    }&#10;&#10;    private void atualizarTabuleiro() {&#10;        for (int linha = 0; linha &lt; Tabuleiro.TAMANHO; linha++) {&#10;            for (int coluna = 0; coluna &lt; Tabuleiro.TAMANHO; coluna++) {&#10;                Peca peca = tabuleiro.getPeca(linha, coluna);&#10;                if (peca == null) {&#10;                    botoes[linha][coluna].setText(&quot;&quot;);&#10;                } else {&#10;                    botoes[linha][coluna].setText(peca.toString());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(XadrezGUI::new);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;&#10;public class XadrezGUI extends JFrame {&#10;    private Tabuleiro tabuleiro;&#10;    private JButton[][] botoes;&#10;    private int origemLinha = -1, origemColuna = -1;&#10;    private JLabel statusLabel;&#10;    private JLabel contagemLabel;&#10;    private JLabel capturadasLabel;&#10;    private JLabel relogioLabel;&#10;    private JTextArea historicoArea;&#10;    private Timer timer;&#10;    private int segundosBranco = 0, segundosPreto = 0;&#10;    private int tempoPersonalizado = 0; // segundos por jogador, 0 = sem limite&#10;&#10;    public XadrezGUI() {&#10;        tabuleiro = new Tabuleiro();&#10;        botoes = new JButton[Tabuleiro.TAMANHO][Tabuleiro.TAMANHO];&#10;        setTitle(&quot;Xadrez&quot;);&#10;        setSize(800, 700);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;        JPanel painelTabuleiro = new JPanel(new GridLayout(Tabuleiro.TAMANHO, Tabuleiro.TAMANHO));&#10;        inicializarBotoes(painelTabuleiro);&#10;        add(painelTabuleiro, BorderLayout.CENTER);&#10;        statusLabel = new JLabel(&quot;Turno: &quot; + tabuleiro.getTurno());&#10;        statusLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 18));&#10;        add(statusLabel, BorderLayout.SOUTH);&#10;        JPanel painelInfo = new JPanel(new BorderLayout());&#10;        contagemLabel = new JLabel();&#10;        contagemLabel.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 16));&#10;        painelInfo.add(contagemLabel, BorderLayout.NORTH);&#10;        historicoArea = new JTextArea(10, 20);&#10;        historicoArea.setEditable(false);&#10;        painelInfo.add(new JScrollPane(historicoArea), BorderLayout.CENTER);&#10;        JButton exportarBtn = new JButton(&quot;Exportar Histórico&quot;);&#10;        exportarBtn.addActionListener(e -&gt; mostrarExportacao());&#10;        painelInfo.add(exportarBtn, BorderLayout.SOUTH);&#10;        capturadasLabel = new JLabel();&#10;        capturadasLabel.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 16));&#10;        painelInfo.add(capturadasLabel, BorderLayout.WEST);&#10;        relogioLabel = new JLabel();&#10;        relogioLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        painelInfo.add(relogioLabel, BorderLayout.EAST);&#10;        JButton tempoBtn = new JButton(&quot;Definir Tempo&quot;);&#10;        tempoBtn.addActionListener(e -&gt; mostrarDialogoTempo());&#10;        painelInfo.add(tempoBtn, BorderLayout.NORTH);&#10;        add(painelInfo, BorderLayout.EAST);&#10;        atualizarTabuleiro();&#10;        atualizarContagemEHistorico();&#10;        iniciarRelogio();&#10;        setVisible(true);&#10;    }&#10;&#10;    private void iniciarRelogio() {&#10;        timer = new Timer(1000, e -&gt; {&#10;            if (tabuleiro.getTurno() == Cor.BRANCO) segundosBranco++;&#10;            else segundosPreto++;&#10;            atualizarRelogio();&#10;            if (tempoPersonalizado &gt; 0) {&#10;                if (segundosBranco &gt;= tempoPersonalizado) {&#10;                    timer.stop();&#10;                    JOptionPane.showMessageDialog(this, &quot;Tempo esgotado para as brancas! Fim de jogo.&quot;, &quot;Tempo&quot;, JOptionPane.INFORMATION_MESSAGE);&#10;                }&#10;                if (segundosPreto &gt;= tempoPersonalizado) {&#10;                    timer.stop();&#10;                    JOptionPane.showMessageDialog(this, &quot;Tempo esgotado para as pretas! Fim de jogo.&quot;, &quot;Tempo&quot;, JOptionPane.INFORMATION_MESSAGE);&#10;                }&#10;            }&#10;        });&#10;        timer.start();&#10;    }&#10;&#10;    private void atualizarRelogio() {&#10;        relogioLabel.setText(&quot;Branco: &quot; + formatarTempo(segundosBranco) + &quot; | Preto: &quot; + formatarTempo(segundosPreto));&#10;    }&#10;&#10;    private String formatarTempo(int s) {&#10;        int min = s / 60;&#10;        int seg = s % 60;&#10;        return String.format(&quot;%02d:%02d&quot;, min, seg);&#10;    }&#10;&#10;    private void salvarHistoricoEmArquivo() {&#10;        JFileChooser chooser = new JFileChooser();&#10;        int op = chooser.showSaveDialog(this);&#10;        if (op == JFileChooser.APPROVE_OPTION) {&#10;            try {&#10;                java.io.File file = chooser.getSelectedFile();&#10;                java.nio.file.Files.write(file.toPath(), tabuleiro.exportarPartida().getBytes());&#10;                JOptionPane.showMessageDialog(this, &quot;Histórico salvo em arquivo!&quot;, &quot;Sucesso&quot;, JOptionPane.INFORMATION_MESSAGE);&#10;            } catch (Exception ex) {&#10;                JOptionPane.showMessageDialog(this, &quot;Erro ao salvar arquivo!&quot;, &quot;Erro&quot;, JOptionPane.ERROR_MESSAGE);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void mostrarExportacao() {&#10;        String texto = tabuleiro.exportarPartida();&#10;        JOptionPane.showMessageDialog(this, texto, &quot;Histórico da Partida&quot;, JOptionPane.INFORMATION_MESSAGE);&#10;        int opt = JOptionPane.showConfirmDialog(this, &quot;Deseja salvar o histórico em arquivo?&quot;, &quot;Salvar&quot;, JOptionPane.YES_NO_OPTION);&#10;        if (opt == JOptionPane.YES_OPTION) {&#10;            salvarHistoricoEmArquivo();&#10;        }&#10;    }&#10;&#10;    private void mostrarDialogoTempo() {&#10;        String min = JOptionPane.showInputDialog(this, &quot;Tempo por jogador (minutos, 0 = sem limite):&quot;, &quot;10&quot;);&#10;        try {&#10;            int minutos = Integer.parseInt(min);&#10;            setTempoPersonalizado(minutos);&#10;        } catch (Exception ex) {&#10;            JOptionPane.showMessageDialog(this, &quot;Valor inválido!&quot;, &quot;Erro&quot;, JOptionPane.ERROR_MESSAGE);&#10;        }&#10;    }&#10;&#10;    // Adiciona método para definir tempo personalizado&#10;    public void setTempoPersonalizado(int minutos) {&#10;        tempoPersonalizado = minutos * 60;&#10;        segundosBranco = 0;&#10;        segundosPreto = 0;&#10;        atualizarRelogio();&#10;    }&#10;&#10;    private void atualizarCapturadas() {&#10;        java.util.List&lt;String&gt; capturadasBrancas = tabuleiro.getPecasCapturadasPorCor(Cor.BRANCO);&#10;        java.util.List&lt;String&gt; capturadasPretas = tabuleiro.getPecasCapturadasPorCor(Cor.PRETO);&#10;        StringBuilder sb = new StringBuilder(&quot;Capturadas - Brancas: &quot;);&#10;        for (String p : capturadasBrancas) sb.append(p).append(&quot; &quot;);&#10;        sb.append(&quot;| Pretas: &quot;);&#10;        for (String p : capturadasPretas) sb.append(p).append(&quot; &quot;);&#10;        capturadasLabel.setText(sb.toString());&#10;    }&#10;&#10;    private void atualizarContagemEHistorico() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;Brancas: &quot;).append(tabuleiro.contarPecas(Cor.BRANCO)).append(&quot;\n&quot;);&#10;        sb.append(&quot;Pretas: &quot;).append(tabuleiro.contarPecas(Cor.PRETO)).append(&quot;\n&quot;);&#10;        contagemLabel.setText(&quot;&lt;html&gt;&quot; + sb.toString().replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;) + &quot;&lt;/html&gt;&quot;);&#10;        StringBuilder hist = new StringBuilder();&#10;        for (String jogada : tabuleiro.getHistoricoJogadas()) {&#10;            hist.append(jogada).append(&quot;\n&quot;);&#10;        }&#10;        historicoArea.setText(hist.toString());&#10;        atualizarCapturadas();&#10;    }&#10;&#10;    private void inicializarBotoes(JPanel painelTabuleiro) {&#10;        for (int linha = 0; linha &lt; Tabuleiro.TAMANHO; linha++) {&#10;            for (int coluna = 0; coluna &lt; Tabuleiro.TAMANHO; coluna++) {&#10;                JButton botao = new JButton();&#10;                botao.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 24));&#10;                botao.setBackground((linha + coluna) % 2 == 0 ? Color.WHITE : Color.GRAY);&#10;                final int l = linha, c = coluna;&#10;                botao.addActionListener(e -&gt; cliqueCasa(l, c));&#10;                botoes[linha][coluna] = botao;&#10;                painelTabuleiro.add(botao);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void cliqueCasa(int linha, int coluna) {&#10;        if (origemLinha == -1 &amp;&amp; tabuleiro.getPeca(linha, coluna) != null &amp;&amp; tabuleiro.getPeca(linha, coluna).getCor() == tabuleiro.getTurno()) {&#10;            origemLinha = linha;&#10;            origemColuna = coluna;&#10;            botoes[linha][coluna].setBackground(Color.YELLOW);&#10;        } else if (origemLinha != -1) {&#10;            if (tabuleiro.movimentoValido(origemLinha, origemColuna, linha, coluna)) {&#10;                tabuleiro.moverPecaComRegras(origemLinha, origemColuna, linha, coluna);&#10;                if (tabuleiro.estaEmXeque(tabuleiro.getTurno())) {&#10;                    statusLabel.setText(&quot;Xeque! Turno: &quot; + tabuleiro.getTurno());&#10;                } else if (tabuleiro.estaEmXequeMate(tabuleiro.getTurno())) {&#10;                    statusLabel.setText(&quot;Xeque-mate! Fim de jogo.&quot;);&#10;                } else if (tabuleiro.estaAfogamento(tabuleiro.getTurno())) {&#10;                    statusLabel.setText(&quot;Empate por afogamento! Fim de jogo.&quot;);&#10;                } else {&#10;                    statusLabel.setText(&quot;Turno: &quot; + tabuleiro.getTurno());&#10;                }&#10;            } else {&#10;                statusLabel.setText(&quot;Movimento inválido! Turno: &quot; + tabuleiro.getTurno());&#10;            }&#10;            botoes[origemLinha][origemColuna].setBackground((origemLinha + origemColuna) % 2 == 0 ? Color.WHITE : Color.GRAY);&#10;            origemLinha = -1;&#10;            origemColuna = -1;&#10;            atualizarTabuleiro();&#10;        }&#10;        atualizarContagemEHistorico();&#10;    }&#10;&#10;    private void atualizarTabuleiro() {&#10;        for (int linha = 0; linha &lt; Tabuleiro.TAMANHO; linha++) {&#10;            for (int coluna = 0; coluna &lt; Tabuleiro.TAMANHO; coluna++) {&#10;                Peca peca = tabuleiro.getPeca(linha, coluna);&#10;                if (peca == null) {&#10;                    botoes[linha][coluna].setText(&quot;&quot;);&#10;                } else {&#10;                    // Usa emojis Unicode para as peças&#10;                    String emoji;&#10;                    if (peca instanceof Rei) emoji = peca.getCor() == Cor.BRANCO ? &quot;&amp;#9812;&quot; : &quot;&amp;#9818;&quot;;&#10;                    else if (peca instanceof Rainha) emoji = peca.getCor() == Cor.BRANCO ? &quot;&amp;#9813;&quot; : &quot;&amp;#9819;&quot;;&#10;                    else if (peca instanceof Torre) emoji = peca.getCor() == Cor.BRANCO ? &quot;&amp;#9814;&quot; : &quot;&amp;#9820;&quot;;&#10;                    else if (peca instanceof Bispo) emoji = peca.getCor() == Cor.BRANCO ? &quot;&amp;#9815;&quot; : &quot;&amp;#9821;&quot;;&#10;                    else if (peca instanceof Cavalo) emoji = peca.getCor() == Cor.BRANCO ? &quot;&amp;#9816;&quot; : &quot;&amp;#9822;&quot;;&#10;                    else if (peca instanceof Peao) emoji = peca.getCor() == Cor.BRANCO ? &quot;&amp;#9817;&quot; : &quot;&amp;#9823;&quot;;&#10;                    else emoji = peca.toString();&#10;                    botoes[linha][coluna].setText(emoji);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(XadrezGUI::new);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>